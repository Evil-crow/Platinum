## Holes and TODO

主要进行`platinum`的设计反思. 以及`TODO`(*至于TODO什么时候能完成, 暂定*)

### 全面支持新特性

`platinum`设计之初是参考`muduo`设计的网络层方面, 其中不免有大大小小`muduo的感觉`
由于`muduo`本身是基于`boost`完成的, 即使现在2.0在准备更新为标准库设施, 仍然有大量`boost`组件残留.`platinum`可以完全基于标准库完成编译运行

但是, 对于提到的一些特性, `platinum`并没有完全切实的做到: 如完全使用`lambda expr`取代所有的`function pointer` 乃至于看不到`std::bind`. 但是还仍然有大量的`function pointer`

`platinum`的更新时间不确定. 但是, 现在使用相同网络层的`levelnet`可以完全支持之前提到过的特性, 使得代码更加简洁优雅 [levelnet](https://github.com/Evil-crow/levelnet)

### 关于WriteQueue的辩证

使用`WriteQueue`一定是优解吗? 这个问题我自己也不好回答,
在大文件的时候, 我们可以直接`sendfile(2)`过去, 但是不可避免的同时执行了两次写操作, 
而且,当有`EAGAIN`的时候, 会使用智能指针拷贝数据, 如果有大量大任务量的任务:
1. 对于`WriteTask`就是有长字符串
2. 对于`SendTask`就是多个文件同时发送

`WriteTask`会导致有大量内存被消耗, 如果任务长时间不能得到执行, 而对于`SendTask`则是有大量文件描述符被消耗, `ulimit -n => 1024`, 不修改内核参数的情况下, 很快会没有fd可用.

着实是比较大的问题.

不过目前还没有这么严重的问题. 任务量爆炸的时候, 即使是`muduo`自己的`buffer`也会异常大, 同样苦不堪言,到这个层次的业务需求, 我觉得已经不能简简单单的在代码层面上优化解决了

*也可能是我错误估计, ...*

### 关于Parser

`Parser`明确应该使用, 虚函数机制完成多种协议实现. 目前仍然只是为了基类指针使用.
并没有使用完整的虚函数继承机制. 使用`stdtic_cast<>`可以保证无BUG, 不过不符合设计的美学.
同时, 不够优雅, 而且本质上来说, 不安全.

这个算为`TODO`, 之后可以尽快进行修改

### 关于多线程模型的问题

`platinum`目前使用`REUSEPORT`进行内核层面上的负载均衡.在同一个端口上, 绑定多个实例进行服务.
所以, 单个`Reactor`中是没有锁的, 可以放心的进行任务调配. 

`REUSEPORT`是内核在3.x后加入的`SOCKET OPTION`之前是热备份模式, 现在是负载均衡模式

热备份模式: 就是进行服务备份, 像PCP链表的形式一样, 如果某个实例挂了, 可以立马备份启动
负载均衡模式: 内核层面负载均衡, 分配连接给不同的服务

可能存在的问题:
 有时需要其他的负载均衡的算法, 如RR或者随机(使用hash)进行负载均衡. 这些都可以在用户层面重新支持. 如果有必要了, 也可以像`muduo`一样, 在多个EventLoop之间进行任务调配.
 
简单地说: 目前的多线程模型就是, 类似于Redis一样的单线程EventLoop, 多个实例绑定的多线程形式

### 是否在抄袭muduo

这怎么说呢, 最开始是在模仿`muduo`写, 后面根据自己的需求修改, 增加, 删除了很多的组件
仅仅保留的Reactor抽象描述, `Java NIO`库`Netty`也是这样实现的, 我觉得算不上抄袭吧,

开源的事, 怎么能说抄呢, ( ՞ټ՞) , 开玩笑的. 仅仅只是一定程度内的借鉴和学习.
